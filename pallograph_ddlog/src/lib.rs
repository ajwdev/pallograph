#![allow(
    unused_imports,
    non_snake_case,
    non_camel_case_types,
    non_upper_case_globals,
    unused_parens,
    non_shorthand_field_patterns,
    dead_code,
    overflowing_literals,
    unreachable_patterns,
    unused_variables,
    clippy::missing_safety_doc,
    clippy::toplevel_ref_arg,
    clippy::double_parens,
    clippy::clone_on_copy,
    clippy::just_underscores_and_digits,
    clippy::match_single_binding,
    clippy::op_ref,
    clippy::nonminimal_bool,
    clippy::redundant_clone
)]

mod inventory;
pub mod ovsdb_api;

pub use inventory::{D3logInventory, Inventory};

use num::bigint::BigInt;
use std::convert::TryFrom;
use std::hash::Hash;
use std::ops::Deref;
use std::result;
use std::{any::TypeId, sync};

use ordered_float::*;

use differential_dataflow::collection;
use timely::communication;
use timely::dataflow::scopes;
use timely::worker;

use differential_datalog::ddval::*;
use differential_datalog::program;
use differential_datalog::record;
use differential_datalog::record::FromRecord;
use differential_datalog::record::IntoRecord;
use differential_datalog::record::RelIdentifier;
use differential_datalog::record::UpdCmd;
use differential_datalog::D3logLocationId;
use num_traits::cast::FromPrimitive;
use num_traits::identities::One;
use once_cell::sync::Lazy;

use fnv::{FnvBuildHasher, FnvHashMap};
use phf::phf_map;

use serde::ser::SerializeTuple;
use serde::Deserialize;
use serde::Deserializer;
use serde::Serialize;
use serde::Serializer;

// This import is only needed to convince the OS X compiler to export
// `extern C` functions declared in ddlog_log.rs in the generated lib.
#[doc(hidden)]
#[cfg(feature = "c_api")]
pub use ddlog_log as hidden_ddlog_log;
#[doc(hidden)]
#[cfg(feature = "c_api")]
pub use differential_datalog::api as hidden_ddlog_api;

pub struct RelValDeserialize;

#[macro_export]
macro_rules! decl_any_deserialize {
    ( $(($rel:expr, $typ:ty)),* ) => {
        #[cfg(feature = "deserialize_any")]
        static DDANY_DESERIALIZE_FUNC_MAP: phf::Map<u64, ::differential_datalog::AnyDeserializeFunc> = phf_map! {
            $(
                $rel => {
                    fn deserialize(deserializer: &mut dyn ::erased_serde::Deserializer) -> Result<::differential_datalog::ddval::Any, ::erased_serde::Error> {
                        <$typ>::deserialize(deserializer).map(|x| ::differential_datalog::ddval::Any::from(x.into_ddvalue()))
                    }
                    deserialize
                },
            )*
        };

        #[cfg(feature = "deserialize_any")]
        impl ::differential_datalog::AnyDeserialize for RelValDeserialize {
            fn get_deserialize(&self, relid: ::differential_datalog::program::RelId) -> ::std::option::Option<::differential_datalog::AnyDeserializeFunc> {
                DDANY_DESERIALIZE_FUNC_MAP.get(&(relid as u64)).cloned()
            }
        }
    };
}

/* FlatBuffers bindings generated by `ddlog` */
#[cfg(feature = "flatbuf")]
pub mod flatbuf;

#[cfg(feature = "flatbuf")]
pub mod flatbuf_generated;

impl TryFrom<&RelIdentifier> for Relations {
    type Error = ();

    fn try_from(rel_id: &RelIdentifier) -> ::std::result::Result<Self, ()> {
        match rel_id {
            RelIdentifier::RelName(rname) => Relations::try_from(rname.as_ref()),
            RelIdentifier::RelId(id) => Relations::try_from(*id),
        }
    }
}

// Macro used to implement `trait D3log`. Invoked from generated code.
#[macro_export]
macro_rules! impl_trait_d3log {
    () => {
        fn d3log_localize_val(
            _relid: ::differential_datalog::program::RelId,
            value: ::differential_datalog::ddval::DDValue,
        ) -> ::core::result::Result<
            (
                ::core::option::Option<::differential_datalog::D3logLocationId>,
                ::differential_datalog::program::RelId,
                ::differential_datalog::ddval::DDValue,
            ),
            ::differential_datalog::ddval::DDValue,
        > {
            ::core::result::Result::Err(value)
        }
    };

    ( $(($out_rel:expr, $in_rel:expr, $typ:ty)),+ ) => {
        pub static D3LOG_CONVERTER_MAP: ::once_cell::sync::Lazy<::std::collections::HashMap<program::RelId, fn(DDValue)->Result<(Option<D3logLocationId>, program::RelId, DDValue), DDValue>>> = ::once_cell::sync::Lazy::new(|| {
            let mut m = ::std::collections::HashMap::new();
            $(
                m.insert($out_rel, { fn __f(val: DDValue) -> Result<(Option<D3logLocationId>, program::RelId, DDValue), DDValue> {
                    if let Some(::ddlog_std::tuple2(loc_id, inner_val)) = <::ddlog_std::tuple2<ddlog_std::Option<D3logLocationId>, $typ>>::try_from_ddvalue_ref(&val) {
                        Ok((::ddlog_std::std2option(*loc_id), $in_rel, (*inner_val).clone().into_ddvalue()))
                    } else {
                        Err(val)
                    }
                } __f as fn(DDValue)->Result<(Option<D3logLocationId>, program::RelId, DDValue), DDValue>});
            )*
            m
        });
        fn d3log_localize_val(relid: program::RelId, val: DDValue) -> Result<(Option<D3logLocationId>, program::RelId, DDValue), DDValue> {
            if let Some(f) = D3LOG_CONVERTER_MAP.get(&relid) {
                f(val)
            } else {
                Err(val)
            }
        }
    };
}

static RAW_RELATION_ID_MAP: ::once_cell::sync::Lazy<
    ::fnv::FnvHashMap<::differential_datalog::program::RelId, &'static ::core::primitive::str>,
> = ::once_cell::sync::Lazy::new(|| {
    let mut map = ::fnv::FnvHashMap::with_capacity_and_hasher(
        crate::RELIDMAP.len(),
        ::fnv::FnvBuildHasher::default(),
    );

    for (&relation, &name) in crate::RELIDMAP.iter() {
        map.insert(relation as ::differential_datalog::program::RelId, name);
    }

    map
});

static RAW_INPUT_RELATION_ID_MAP: ::once_cell::sync::Lazy<
    ::fnv::FnvHashMap<::differential_datalog::program::RelId, &'static ::core::primitive::str>,
> = ::once_cell::sync::Lazy::new(|| {
    let mut map = ::fnv::FnvHashMap::with_capacity_and_hasher(
        crate::INPUT_RELIDMAP.len(),
        ::fnv::FnvBuildHasher::default(),
    );

    for (&relation, &name) in crate::INPUT_RELIDMAP.iter() {
        map.insert(relation as ::differential_datalog::program::RelId, name);
    }

    map
});

pub static SOURCE_CODE: ddlog_profiler::DDlogSourceCode =
    ddlog_profiler::DDlogSourceCode { code: SOURCES };

/// Create an instance of the DDlog program.
///
/// `config` - program configuration.
/// `do_store` - indicates whether DDlog will track the complete snapshot
///   of output relations.  Should only be used for debugging in order to dump
///   the contents of output tables using `HDDlog::dump_table()`.  Otherwise,
///   indexes are the preferred way to achieve this.
///
/// Returns a handle to the program and initial contents of output relations.
pub fn run_with_config(
    config: ::differential_datalog::program::config::Config,
    do_store: bool,
) -> Result<
    (
        ::differential_datalog::api::HDDlog,
        ::differential_datalog::DeltaMap<DDValue>,
    ),
    String,
> {
    #[cfg(feature = "flatbuf")]
    let flatbuf_converter = Box::new(crate::flatbuf::DDlogFlatbufConverter);
    #[cfg(not(feature = "flatbuf"))]
    let flatbuf_converter = Box::new(differential_datalog::flatbuf::UnimplementedFlatbufConverter);

    #[cfg(feature = "deserialize_any")]
    let deserialize_any = Some(Box::new(RelValDeserialize)
        as Box<dyn ::differential_datalog::AnyDeserialize + Send + Sync + 'static>);
    #[cfg(not(feature = "deserialize_any"))]
    let deserialize_any = None;

    ::differential_datalog::api::HDDlog::new(
        config,
        &SOURCE_CODE,
        do_store,
        None,
        crate::prog,
        Box::new(crate::Inventory),
        deserialize_any,
        Box::new(crate::D3logInventory),
        flatbuf_converter,
    )
}

/// Create an instance of the DDlog program with default configuration.
///
/// `workers` - number of worker threads (typical values are in the range from 1 to 4).
/// `do_store` - indicates whether DDlog will track the complete snapshot
///   of output relations.  Should only be used for debugging in order to dump
///   the contents of output tables using `HDDlog::dump_table()`.  Otherwise,
///   indexes are the preferred way to achieve this.
///
/// Returns a handle to the program and initial contents of output relations.
pub fn run(
    workers: usize,
    do_store: bool,
) -> Result<
    (
        ::differential_datalog::api::HDDlog,
        ::differential_datalog::DeltaMap<DDValue>,
    ),
    String,
> {
    let config =
        ::differential_datalog::program::config::Config::new().with_timely_workers(workers);

    #[cfg(feature = "flatbuf")]
    let flatbuf_converter = Box::new(crate::flatbuf::DDlogFlatbufConverter);
    #[cfg(not(feature = "flatbuf"))]
    let flatbuf_converter = Box::new(differential_datalog::flatbuf::UnimplementedFlatbufConverter);

    #[cfg(feature = "deserialize_any")]
    let deserialize_any = Some(Box::new(RelValDeserialize)
        as Box<dyn ::differential_datalog::AnyDeserialize + Send + Sync + 'static>);
    #[cfg(not(feature = "deserialize_any"))]
    let deserialize_any = None;

    ::differential_datalog::api::HDDlog::new(
        config,
        &SOURCE_CODE,
        do_store,
        None,
        crate::prog,
        Box::new(crate::Inventory),
        deserialize_any,
        Box::new(crate::D3logInventory),
        flatbuf_converter,
    )
}

#[no_mangle]
#[cfg(feature = "c_api")]
pub unsafe extern "C" fn ddlog_run_with_config(
    config: *const ::differential_datalog::api::ddlog_config,
    do_store: bool,
    print_err: Option<extern "C" fn(msg: *const ::std::os::raw::c_char)>,
    init_state: *mut *mut ::differential_datalog::DeltaMap<DDValue>,
) -> *const ::differential_datalog::api::HDDlog {
    use ::core::{
        ptr,
        result::Result::{Err, Ok},
    };
    use ::differential_datalog::api::HDDlog;
    use ::std::{boxed::Box, format};
    use ::triomphe::Arc;

    let config = match config.as_ref() {
        None => Default::default(),
        Some(config) => match config.to_rust_api() {
            Ok(cfg) => cfg,
            Err(err) => {
                HDDlog::print_err(
                    print_err,
                    &format!("ddlog_run_with_config(): invalid config: {}", err),
                );
                return ptr::null();
            }
        },
    };

    #[cfg(feature = "flatbuf")]
    let flatbuf_converter = Box::new(crate::flatbuf::DDlogFlatbufConverter);
    #[cfg(not(feature = "flatbuf"))]
    let flatbuf_converter = Box::new(differential_datalog::flatbuf::UnimplementedFlatbufConverter);

    #[cfg(feature = "deserialize_any")]
    let deserialize_any = Some(Box::new(RelValDeserialize)
        as Box<dyn ::differential_datalog::AnyDeserialize + Send + Sync + 'static>);
    #[cfg(not(feature = "deserialize_any"))]
    let deserialize_any = None;

    let result = HDDlog::new(
        config,
        &SOURCE_CODE,
        do_store,
        print_err,
        crate::prog,
        Box::new(crate::Inventory),
        deserialize_any,
        Box::new(crate::D3logInventory),
        flatbuf_converter,
    );

    match result {
        Ok((hddlog, init)) => {
            if !init_state.is_null() {
                *init_state = Box::into_raw(Box::new(init));
            }
            // Note: This is `triomphe::Arc`, *not* `std::sync::Arc`
            Arc::into_raw(Arc::new(hddlog))
        }
        Err(err) => {
            HDDlog::print_err(print_err, &format!("HDDlog::new() failed: {}", err));
            ptr::null()
        }
    }
}

#[no_mangle]
#[cfg(feature = "c_api")]
pub unsafe extern "C" fn ddlog_run(
    workers: ::std::os::raw::c_uint,
    do_store: bool,
    print_err: Option<extern "C" fn(msg: *const ::std::os::raw::c_char)>,
    init_state: *mut *mut ::differential_datalog::DeltaMap<DDValue>,
) -> *const ::differential_datalog::api::HDDlog {
    let config = ::differential_datalog::api::ddlog_config {
        num_timely_workers: workers,
        ..Default::default()
    };
    ddlog_run_with_config(&config, do_store, print_err, init_state)
}


pub mod typedefs
{
    pub use ::types::NodesInUse;
    pub use ::types::IsPublic;
    pub use ::types::IngressController;
    pub mod appsv1
    {
        pub use ::types__appsv1::ReplicaSetStatus;
        pub use ::types__appsv1::ReplicaSetSpec;
        pub use ::types__appsv1::ReplicaSetMatchesPod;
        pub use ::types__appsv1::ReplicaSetByName;
        pub use ::types__appsv1::ReplicaSet;
    }
    pub mod corev1
    {
        pub use ::types__corev1::ServiceType;
        pub use ::types__corev1::ServiceStatus;
        pub use ::types__corev1::ServiceSpec;
        pub use ::types__corev1::ServiceMatchesPod;
        pub use ::types__corev1::ServiceByName;
        pub use ::types__corev1::Service;
        pub use ::types__corev1::Selectors;
        pub use ::types__corev1::PodStatus;
        pub use ::types__corev1::PodSpec;
        pub use ::types__corev1::PodPhase;
        pub use ::types__corev1::PodByName;
        pub use ::types__corev1::Pod;
        pub use ::types__corev1::MatchesPod;
    }
    pub mod ddlog_std
    {
        pub use ::ddlog_std::s8;
        pub use ::ddlog_std::s64;
        pub use ::ddlog_std::s32;
        pub use ::ddlog_std::s16;
        pub use ::ddlog_std::s128;
        pub use ::ddlog_std::Vec;
        pub use ::ddlog_std::Singleton;
        pub use ::ddlog_std::Set;
        pub use ::ddlog_std::Result;
        pub use ::ddlog_std::Ref;
        pub use ::ddlog_std::Option;
        pub use ::ddlog_std::Map;
        pub use ::ddlog_std::Group;
        pub use ::ddlog_std::Either;
        pub use ::ddlog_std::DDlogGroup;
        pub use ::ddlog_std::DDWeight;
        pub use ::ddlog_std::DDNestedTS;
        pub use ::ddlog_std::DDIteration;
        pub use ::ddlog_std::DDEpoch;
        pub use ::ddlog_std::D3logLocationId;
        pub use ::ddlog_std::Any;
        pub use ::ddlog_std::zip;
        pub use ::ddlog_std::vec_zip;
        pub use ::ddlog_std::vec_with_length;
        pub use ::ddlog_std::vec_with_capacity;
        pub use ::ddlog_std::vec_update_nth;
        pub use ::ddlog_std::vec_unzip;
        pub use ::ddlog_std::vec_truncate;
        pub use ::ddlog_std::vec_to_set;
        pub use ::ddlog_std::vec_swap_nth;
        pub use ::ddlog_std::vec_sort_imm;
        pub use ::ddlog_std::vec_sort;
        pub use ::ddlog_std::vec_singleton;
        pub use ::ddlog_std::vec_reverse;
        pub use ::ddlog_std::vec_resize;
        pub use ::ddlog_std::vec_push_imm;
        pub use ::ddlog_std::vec_push;
        pub use ::ddlog_std::vec_pop;
        pub use ::ddlog_std::vec_nth;
        pub use ::ddlog_std::vec_len;
        pub use ::ddlog_std::vec_is_empty;
        pub use ::ddlog_std::vec_empty;
        pub use ::ddlog_std::vec_contains;
        pub use ::ddlog_std::vec_append;
        pub use ::ddlog_std::values;
        pub use ::ddlog_std::update_nth;
        pub use ::ddlog_std::unzip;
        pub use ::ddlog_std::unwrap_or_default_ddlog_std_Result__V_E_V;
        pub use ::ddlog_std::unwrap_or_default_ddlog_std_Option__A_A;
        pub use ::ddlog_std::unwrap_or_ddlog_std_Result__V_E_V_V;
        pub use ::ddlog_std::unwrap_or_ddlog_std_Option__A_A_A;
        pub use ::ddlog_std::unions;
        pub use ::ddlog_std::union_ddlog_std_Vec__ddlog_std_Set__X_ddlog_std_Set__X;
        pub use ::ddlog_std::union_ddlog_std_Set__X_ddlog_std_Set__X_ddlog_std_Set__X;
        pub use ::ddlog_std::union_ddlog_std_Map__K_V_ddlog_std_Map__K_V_ddlog_std_Map__K_V;
        pub use ::ddlog_std::union_ddlog_std_Group__K_ddlog_std_Ref__ddlog_std_Set__A_ddlog_std_Ref__ddlog_std_Set__A;
        pub use ::ddlog_std::union_ddlog_std_Group__K_ddlog_std_Set__A_ddlog_std_Set__A;
        pub use ::ddlog_std::u8_pow32;
        pub use ::ddlog_std::u64_pow32;
        pub use ::ddlog_std::u32_pow32;
        pub use ::ddlog_std::u16_pow32;
        pub use ::ddlog_std::u128_pow32;
        pub use ::ddlog_std::truncate;
        pub use ::ddlog_std::trim;
        pub use ::ddlog_std::to_vec_ddlog_std_Set__A_ddlog_std_Vec__A;
        pub use ::ddlog_std::to_vec_ddlog_std_Group__K_V_ddlog_std_Vec__V;
        pub use ::ddlog_std::to_vec_ddlog_std_Option__X_ddlog_std_Vec__X;
        pub use ::ddlog_std::to_uppercase;
        pub use ::ddlog_std::to_string_debug;
        pub use ::ddlog_std::to_string___Stringval___Stringval;
        pub use ::ddlog_std::to_string___Bitval128___Stringval;
        pub use ::ddlog_std::to_string___Bitval64___Stringval;
        pub use ::ddlog_std::to_string___Bitval32___Stringval;
        pub use ::ddlog_std::to_string___Bitval16___Stringval;
        pub use ::ddlog_std::to_string___Bitval8___Stringval;
        pub use ::ddlog_std::to_string___Signedval128___Stringval;
        pub use ::ddlog_std::to_string___Signedval64___Stringval;
        pub use ::ddlog_std::to_string___Signedval32___Stringval;
        pub use ::ddlog_std::to_string___Signedval16___Stringval;
        pub use ::ddlog_std::to_string___Signedval8___Stringval;
        pub use ::ddlog_std::to_string___Doubleval___Stringval;
        pub use ::ddlog_std::to_string___Floatval___Stringval;
        pub use ::ddlog_std::to_string___Intval___Stringval;
        pub use ::ddlog_std::to_string___Boolval___Stringval;
        pub use ::ddlog_std::to_string_ddlog_std_DDNestedTS___Stringval;
        pub use ::ddlog_std::to_setmap;
        pub use ::ddlog_std::to_set_ddlog_std_Vec__A_ddlog_std_Set__A;
        pub use ::ddlog_std::to_set_ddlog_std_Group__K_V_ddlog_std_Set__V;
        pub use ::ddlog_std::to_set_ddlog_std_Option__X_ddlog_std_Set__X;
        pub use ::ddlog_std::to_map_ddlog_std_Vec____Tuple2__K_V_ddlog_std_Map__K_V;
        pub use ::ddlog_std::to_map_ddlog_std_Group__K1___Tuple2__K2_V_ddlog_std_Map__K2_V;
        pub use ::ddlog_std::to_lowercase;
        pub use ::ddlog_std::to_bytes;
        pub use ::ddlog_std::to_any;
        pub use ::ddlog_std::swap_nth;
        pub use ::ddlog_std::substr;
        pub use ::ddlog_std::string_trim;
        pub use ::ddlog_std::string_to_uppercase;
        pub use ::ddlog_std::string_to_lowercase;
        pub use ::ddlog_std::string_to_bytes;
        pub use ::ddlog_std::string_substr;
        pub use ::ddlog_std::string_starts_with;
        pub use ::ddlog_std::string_split;
        pub use ::ddlog_std::string_reverse;
        pub use ::ddlog_std::string_replace;
        pub use ::ddlog_std::string_len;
        pub use ::ddlog_std::string_join;
        pub use ::ddlog_std::string_ends_with;
        pub use ::ddlog_std::string_contains;
        pub use ::ddlog_std::str_to_lower;
        pub use ::ddlog_std::starts_with;
        pub use ::ddlog_std::split;
        pub use ::ddlog_std::sort_imm;
        pub use ::ddlog_std::sort;
        pub use ::ddlog_std::size_ddlog_std_Set__X___Bitval64;
        pub use ::ddlog_std::size_ddlog_std_Map__K_V___Bitval64;
        pub use ::ddlog_std::setref_unions;
        pub use ::ddlog_std::set_unions;
        pub use ::ddlog_std::set_union;
        pub use ::ddlog_std::set_to_vec;
        pub use ::ddlog_std::set_size;
        pub use ::ddlog_std::set_singleton;
        pub use ::ddlog_std::set_nth;
        pub use ::ddlog_std::set_is_empty;
        pub use ::ddlog_std::set_intersection;
        pub use ::ddlog_std::set_insert_imm;
        pub use ::ddlog_std::set_insert;
        pub use ::ddlog_std::set_empty;
        pub use ::ddlog_std::set_difference;
        pub use ::ddlog_std::set_contains;
        pub use ::ddlog_std::s8_pow32;
        pub use ::ddlog_std::s64_pow32;
        pub use ::ddlog_std::s32_pow32;
        pub use ::ddlog_std::s16_pow32;
        pub use ::ddlog_std::s128_pow32;
        pub use ::ddlog_std::reverse_imm;
        pub use ::ddlog_std::reverse_ddlog_std_Vec__X___Tuple0__;
        pub use ::ddlog_std::reverse___Stringval___Stringval;
        pub use ::ddlog_std::result_unwrap_or_default;
        pub use ::ddlog_std::result_unwrap_or;
        pub use ::ddlog_std::resize;
        pub use ::ddlog_std::replace;
        pub use ::ddlog_std::remove;
        pub use ::ddlog_std::ref_new;
        pub use ::ddlog_std::range_vec;
        pub use ::ddlog_std::push_imm;
        pub use ::ddlog_std::push;
        pub use ::ddlog_std::pow32___Intval___Bitval32___Intval;
        pub use ::ddlog_std::pow32___Signedval128___Bitval32___Signedval128;
        pub use ::ddlog_std::pow32___Signedval64___Bitval32___Signedval64;
        pub use ::ddlog_std::pow32___Signedval32___Bitval32___Signedval32;
        pub use ::ddlog_std::pow32___Signedval16___Bitval32___Signedval16;
        pub use ::ddlog_std::pow32___Signedval8___Bitval32___Signedval8;
        pub use ::ddlog_std::pow32___Bitval128___Bitval32___Bitval128;
        pub use ::ddlog_std::pow32___Bitval64___Bitval32___Bitval64;
        pub use ::ddlog_std::pow32___Bitval32___Bitval32___Bitval32;
        pub use ::ddlog_std::pow32___Bitval16___Bitval32___Bitval16;
        pub use ::ddlog_std::pow32___Bitval8___Bitval32___Bitval8;
        pub use ::ddlog_std::pop;
        pub use ::ddlog_std::parse_dec_u64;
        pub use ::ddlog_std::parse_dec_i64;
        pub use ::ddlog_std::option_unwrap_or_default;
        pub use ::ddlog_std::option_unwrap_or;
        pub use ::ddlog_std::ok_or_else;
        pub use ::ddlog_std::ok_or;
        pub use ::ddlog_std::ntohs;
        pub use ::ddlog_std::ntohl;
        pub use ::ddlog_std::nth_value;
        pub use ::ddlog_std::nth_key;
        pub use ::ddlog_std::nth_ddlog_std_Set__X___Bitval64_ddlog_std_Option__X;
        pub use ::ddlog_std::nth_ddlog_std_Vec__X___Bitval64_ddlog_std_Option__X;
        pub use ::ddlog_std::nth_ddlog_std_Group__K_V___Bitval64_ddlog_std_Option__V;
        pub use ::ddlog_std::min_ddlog_std_Group__K_V_V;
        pub use ::ddlog_std::min_A_A_A;
        pub use ::ddlog_std::max_ddlog_std_Group__K_V_V;
        pub use ::ddlog_std::max_A_A_A;
        pub use ::ddlog_std::map_values;
        pub use ::ddlog_std::map_union;
        pub use ::ddlog_std::map_size;
        pub use ::ddlog_std::map_singleton;
        pub use ::ddlog_std::map_remove;
        pub use ::ddlog_std::map_nth_value;
        pub use ::ddlog_std::map_nth_key;
        pub use ::ddlog_std::map_keys;
        pub use ::ddlog_std::map_is_empty;
        pub use ::ddlog_std::map_insert_imm;
        pub use ::ddlog_std::map_insert;
        pub use ::ddlog_std::map_get;
        pub use ::ddlog_std::map_err;
        pub use ::ddlog_std::map_empty;
        pub use ::ddlog_std::map_contains_key;
        pub use ::ddlog_std::map_ddlog_std_Result__V1_E___Closureimm_V1_ret_V2_ddlog_std_Result__V2_E;
        pub use ::ddlog_std::map_ddlog_std_Option__A___Closureimm_A_ret_B_ddlog_std_Option__B;
        pub use ::ddlog_std::len_ddlog_std_Vec__X___Bitval64;
        pub use ::ddlog_std::len___Stringval___Bitval64;
        pub use ::ddlog_std::keys;
        pub use ::ddlog_std::key;
        pub use ::ddlog_std::join;
        pub use ::ddlog_std::is_some;
        pub use ::ddlog_std::is_ok;
        pub use ::ddlog_std::is_none;
        pub use ::ddlog_std::is_err;
        pub use ::ddlog_std::is_empty_ddlog_std_Set__X___Boolval;
        pub use ::ddlog_std::is_empty_ddlog_std_Map__K_V___Boolval;
        pub use ::ddlog_std::is_empty_ddlog_std_Vec__X___Boolval;
        pub use ::ddlog_std::intersection;
        pub use ::ddlog_std::insert_imm_ddlog_std_Set__X_X_ddlog_std_Set__X;
        pub use ::ddlog_std::insert_imm_ddlog_std_Map__K_V_K_V_ddlog_std_Map__K_V;
        pub use ::ddlog_std::insert_ddlog_std_Set__X_X___Tuple0__;
        pub use ::ddlog_std::insert_ddlog_std_Map__K_V_K_V___Tuple0__;
        pub use ::ddlog_std::htons;
        pub use ::ddlog_std::htonl;
        pub use ::ddlog_std::hex;
        pub use ::ddlog_std::hash64;
        pub use ::ddlog_std::hash32;
        pub use ::ddlog_std::hash128;
        pub use ::ddlog_std::group_unzip;
        pub use ::ddlog_std::group_to_vec;
        pub use ::ddlog_std::group_to_setmap;
        pub use ::ddlog_std::group_to_set;
        pub use ::ddlog_std::group_to_map;
        pub use ::ddlog_std::group_setref_unions;
        pub use ::ddlog_std::group_set_unions;
        pub use ::ddlog_std::group_nth;
        pub use ::ddlog_std::group_min;
        pub use ::ddlog_std::group_max;
        pub use ::ddlog_std::group_key;
        pub use ::ddlog_std::group_first;
        pub use ::ddlog_std::group_count_distinct;
        pub use ::ddlog_std::get;
        pub use ::ddlog_std::from_utf8;
        pub use ::ddlog_std::from_utf16;
        pub use ::ddlog_std::from_any;
        pub use ::ddlog_std::first;
        pub use ::ddlog_std::ends_with;
        pub use ::ddlog_std::encode_utf16;
        pub use ::ddlog_std::difference;
        pub use ::ddlog_std::deref;
        pub use ::ddlog_std::default;
        pub use ::ddlog_std::count_distinct;
        pub use ::ddlog_std::contains_key;
        pub use ::ddlog_std::contains_ddlog_std_Set__X_X___Boolval;
        pub use ::ddlog_std::contains_ddlog_std_Vec__X_X___Boolval;
        pub use ::ddlog_std::contains___Stringval___Stringval___Boolval;
        pub use ::ddlog_std::bigint_pow32;
        pub use ::ddlog_std::append;
        pub use ::ddlog_std::and_then;
        pub use ::ddlog_std::__builtin_2string;
    }
    pub mod debug
    {
        pub use ::debug::DDlogOpId;
        pub use ::debug::debug_split_group;
        pub use ::debug::debug_event_join;
        pub use ::debug::debug_event;
    }
    pub mod internment
    {
        pub use ::internment::istring;
        pub use ::internment::Intern;
        pub use ::internment::trim;
        pub use ::internment::to_uppercase;
        pub use ::internment::to_string;
        pub use ::internment::to_lowercase;
        pub use ::internment::to_bytes;
        pub use ::internment::substr;
        pub use ::internment::starts_with;
        pub use ::internment::split;
        pub use ::internment::reverse;
        pub use ::internment::replace;
        pub use ::internment::parse_dec_u64;
        pub use ::internment::parse_dec_i64;
        pub use ::internment::len;
        pub use ::internment::join;
        pub use ::internment::ival;
        pub use ::internment::istring_trim;
        pub use ::internment::istring_to_uppercase;
        pub use ::internment::istring_to_lowercase;
        pub use ::internment::istring_to_bytes;
        pub use ::internment::istring_substr;
        pub use ::internment::istring_starts_with;
        pub use ::internment::istring_split;
        pub use ::internment::istring_reverse;
        pub use ::internment::istring_replace;
        pub use ::internment::istring_len;
        pub use ::internment::istring_join;
        pub use ::internment::istring_ends_with;
        pub use ::internment::istring_contains;
        pub use ::internment::intern;
        pub use ::internment::ends_with;
        pub use ::internment::contains;
    }
    pub mod metav1
    {
        pub use ::types__metav1::ObjectMeta;
    }
    pub mod networkingv1
    {
        pub use ::types__networkingv1::IngressToService;
        pub use ::types__networkingv1::IngressStatus;
        pub use ::types__networkingv1::IngressSpec;
        pub use ::types__networkingv1::IngressRule;
        pub use ::types__networkingv1::IngressByName;
        pub use ::types__networkingv1::Ingress;
    }
    pub mod selectors
    {
        pub use ::types__selectors::LabelSelectorRequirement;
        pub use ::types__selectors::LabelSelectorOperator;
        pub use ::types__selectors::LabelSelector;
        pub use ::types__selectors::to_string;
        pub use ::types__selectors::labelSelectorMatches;
    }
}
decl_any_deserialize!((0u64 , types::IngressController), (1u64 , types::IsPublic), (2u64 , types::NodesInUse), (3u64 , ddlog_std::Ref<types__appsv1::ReplicaSet>), (5u64 , types__appsv1::ReplicaSetMatchesPod), (6u64 , types__corev1::MatchesPod), (7u64 , ddlog_std::Ref<types__corev1::Pod>), (9u64 , types__corev1::Selectors), (10u64 , ddlog_std::Ref<types__corev1::Service>), (12u64 , types__corev1::ServiceMatchesPod), (14u64 , ddlog_std::Ref<types__networkingv1::Ingress>), (16u64 , types__networkingv1::IngressToService));
impl TryFrom<&str> for Relations {
    type Error = ();
    fn try_from(rname: &str) -> ::std::result::Result<Self, ()> {
         match rname {
        "IngressController" => Ok(Relations::IngressController),
        "IsPublic" => Ok(Relations::IsPublic),
        "NodesInUse" => Ok(Relations::NodesInUse),
        "appsv1::ReplicaSet" => Ok(Relations::appsv1_ReplicaSet),
        "appsv1::ReplicaSetByName" => Ok(Relations::appsv1_ReplicaSetByName),
        "appsv1::ReplicaSetMatchesPod" => Ok(Relations::appsv1_ReplicaSetMatchesPod),
        "corev1::MatchesPod" => Ok(Relations::corev1_MatchesPod),
        "corev1::Pod" => Ok(Relations::corev1_Pod),
        "corev1::PodByName" => Ok(Relations::corev1_PodByName),
        "corev1::Selectors" => Ok(Relations::corev1_Selectors),
        "corev1::Service" => Ok(Relations::corev1_Service),
        "corev1::ServiceByName" => Ok(Relations::corev1_ServiceByName),
        "corev1::ServiceMatchesPod" => Ok(Relations::corev1_ServiceMatchesPod),
        "ddlog_std::Singleton" => Ok(Relations::ddlog_std_Singleton),
        "networkingv1::Ingress" => Ok(Relations::networkingv1_Ingress),
        "networkingv1::IngressByName" => Ok(Relations::networkingv1_IngressByName),
        "networkingv1::IngressToService" => Ok(Relations::networkingv1_IngressToService),
             _  => Err(()),
         }
    }
}
impl Relations {
    pub fn is_output(&self) -> bool {
        match self {
        Relations::IsPublic => true,
        Relations::NodesInUse => true,
        Relations::appsv1_ReplicaSetMatchesPod => true,
        Relations::corev1_MatchesPod => true,
        Relations::corev1_ServiceMatchesPod => true,
        Relations::networkingv1_IngressToService => true,
            _  => false
        }
    }
}
impl Relations {
    pub fn is_input(&self) -> bool {
        match self {
        Relations::IngressController => true,
        Relations::appsv1_ReplicaSet => true,
        Relations::corev1_Pod => true,
        Relations::corev1_Selectors => true,
        Relations::corev1_Service => true,
        Relations::networkingv1_Ingress => true,
            _  => false
        }
    }
}
impl Relations {
    pub fn type_id(&self) -> ::std::any::TypeId {
        match self {
            Relations::IngressController => ::std::any::TypeId::of::<types::IngressController>(),
            Relations::IsPublic => ::std::any::TypeId::of::<types::IsPublic>(),
            Relations::NodesInUse => ::std::any::TypeId::of::<types::NodesInUse>(),
            Relations::appsv1_ReplicaSet => ::std::any::TypeId::of::<ddlog_std::Ref<types__appsv1::ReplicaSet>>(),
            Relations::appsv1_ReplicaSetByName => ::std::any::TypeId::of::<types__appsv1::ReplicaSetByName>(),
            Relations::appsv1_ReplicaSetMatchesPod => ::std::any::TypeId::of::<types__appsv1::ReplicaSetMatchesPod>(),
            Relations::corev1_MatchesPod => ::std::any::TypeId::of::<types__corev1::MatchesPod>(),
            Relations::corev1_Pod => ::std::any::TypeId::of::<ddlog_std::Ref<types__corev1::Pod>>(),
            Relations::corev1_PodByName => ::std::any::TypeId::of::<types__corev1::PodByName>(),
            Relations::corev1_Selectors => ::std::any::TypeId::of::<types__corev1::Selectors>(),
            Relations::corev1_Service => ::std::any::TypeId::of::<ddlog_std::Ref<types__corev1::Service>>(),
            Relations::corev1_ServiceByName => ::std::any::TypeId::of::<types__corev1::ServiceByName>(),
            Relations::corev1_ServiceMatchesPod => ::std::any::TypeId::of::<types__corev1::ServiceMatchesPod>(),
            Relations::ddlog_std_Singleton => ::std::any::TypeId::of::<ddlog_std::Singleton>(),
            Relations::networkingv1_Ingress => ::std::any::TypeId::of::<ddlog_std::Ref<types__networkingv1::Ingress>>(),
            Relations::networkingv1_IngressByName => ::std::any::TypeId::of::<types__networkingv1::IngressByName>(),
            Relations::networkingv1_IngressToService => ::std::any::TypeId::of::<types__networkingv1::IngressToService>(),
        }
    }
}
impl TryFrom<program::RelId> for Relations {
    type Error = ();
    fn try_from(rid: program::RelId) -> ::std::result::Result<Self, ()> {
         match rid {
        0 => Ok(Relations::IngressController),
        1 => Ok(Relations::IsPublic),
        2 => Ok(Relations::NodesInUse),
        3 => Ok(Relations::appsv1_ReplicaSet),
        4 => Ok(Relations::appsv1_ReplicaSetByName),
        5 => Ok(Relations::appsv1_ReplicaSetMatchesPod),
        6 => Ok(Relations::corev1_MatchesPod),
        7 => Ok(Relations::corev1_Pod),
        8 => Ok(Relations::corev1_PodByName),
        9 => Ok(Relations::corev1_Selectors),
        10 => Ok(Relations::corev1_Service),
        11 => Ok(Relations::corev1_ServiceByName),
        12 => Ok(Relations::corev1_ServiceMatchesPod),
        13 => Ok(Relations::ddlog_std_Singleton),
        14 => Ok(Relations::networkingv1_Ingress),
        15 => Ok(Relations::networkingv1_IngressByName),
        16 => Ok(Relations::networkingv1_IngressToService),
             _  => Err(())
         }
    }
}
pub fn relid2name(rid: program::RelId) -> ::std::option::Option<&'static str> {
   match rid {
        0 => ::core::option::Option::Some("IngressController"),
        1 => ::core::option::Option::Some("IsPublic"),
        2 => ::core::option::Option::Some("NodesInUse"),
        3 => ::core::option::Option::Some("appsv1::ReplicaSet"),
        4 => ::core::option::Option::Some("appsv1::ReplicaSetByName"),
        5 => ::core::option::Option::Some("appsv1::ReplicaSetMatchesPod"),
        6 => ::core::option::Option::Some("corev1::MatchesPod"),
        7 => ::core::option::Option::Some("corev1::Pod"),
        8 => ::core::option::Option::Some("corev1::PodByName"),
        9 => ::core::option::Option::Some("corev1::Selectors"),
        10 => ::core::option::Option::Some("corev1::Service"),
        11 => ::core::option::Option::Some("corev1::ServiceByName"),
        12 => ::core::option::Option::Some("corev1::ServiceMatchesPod"),
        13 => ::core::option::Option::Some("ddlog_std::Singleton"),
        14 => ::core::option::Option::Some("networkingv1::Ingress"),
        15 => ::core::option::Option::Some("networkingv1::IngressByName"),
        16 => ::core::option::Option::Some("networkingv1::IngressToService"),
       _  => None
   }
}
#[cfg(feature = "c_api")]
pub fn relid2cname(rid: program::RelId) -> ::std::option::Option<&'static ::std::ffi::CStr> {
    RELIDMAPC.get(&rid).copied()
}
pub fn rel_name2orig_name(rname: &str) -> ::std::option::Option<&'static str> {
   match rname {
        "IngressController" => ::core::option::Option::Some("IngressController"),
        "IsPublic" => ::core::option::Option::Some("IsPublic"),
        "NodesInUse" => ::core::option::Option::Some("NodesInUse"),
        "appsv1::ReplicaSet" => ::core::option::Option::Some("appsv1::ReplicaSet"),
        "appsv1::ReplicaSetByName" => ::core::option::Option::Some("appsv1::ReplicaSetByName"),
        "appsv1::ReplicaSetMatchesPod" => ::core::option::Option::Some("appsv1::ReplicaSetMatchesPod"),
        "corev1::MatchesPod" => ::core::option::Option::Some("corev1::MatchesPod"),
        "corev1::Pod" => ::core::option::Option::Some("corev1::Pod"),
        "corev1::PodByName" => ::core::option::Option::Some("corev1::PodByName"),
        "corev1::Selectors" => ::core::option::Option::Some("corev1::Selectors"),
        "corev1::Service" => ::core::option::Option::Some("corev1::Service"),
        "corev1::ServiceByName" => ::core::option::Option::Some("corev1::ServiceByName"),
        "corev1::ServiceMatchesPod" => ::core::option::Option::Some("corev1::ServiceMatchesPod"),
        "ddlog_std::Singleton" => ::core::option::Option::Some("ddlog_std::Singleton"),
        "networkingv1::Ingress" => ::core::option::Option::Some("networkingv1::Ingress"),
        "networkingv1::IngressByName" => ::core::option::Option::Some("networkingv1::IngressByName"),
        "networkingv1::IngressToService" => ::core::option::Option::Some("networkingv1::IngressToService"),
       _  => None
   }
}
#[cfg(feature = "c_api")]
pub fn rel_name2orig_cname(rname: &str) -> ::std::option::Option<&'static ::std::ffi::CStr> {
   match rname {
        "IngressController" => Some(::std::ffi::CStr::from_bytes_with_nul(b"IngressController\0") .expect("Unreachable: A null byte was specifically inserted")),
        "IsPublic" => Some(::std::ffi::CStr::from_bytes_with_nul(b"IsPublic\0") .expect("Unreachable: A null byte was specifically inserted")),
        "NodesInUse" => Some(::std::ffi::CStr::from_bytes_with_nul(b"NodesInUse\0") .expect("Unreachable: A null byte was specifically inserted")),
        "appsv1::ReplicaSet" => Some(::std::ffi::CStr::from_bytes_with_nul(b"appsv1::ReplicaSet\0") .expect("Unreachable: A null byte was specifically inserted")),
        "appsv1::ReplicaSetByName" => Some(::std::ffi::CStr::from_bytes_with_nul(b"appsv1::ReplicaSetByName\0") .expect("Unreachable: A null byte was specifically inserted")),
        "appsv1::ReplicaSetMatchesPod" => Some(::std::ffi::CStr::from_bytes_with_nul(b"appsv1::ReplicaSetMatchesPod\0") .expect("Unreachable: A null byte was specifically inserted")),
        "corev1::MatchesPod" => Some(::std::ffi::CStr::from_bytes_with_nul(b"corev1::MatchesPod\0") .expect("Unreachable: A null byte was specifically inserted")),
        "corev1::Pod" => Some(::std::ffi::CStr::from_bytes_with_nul(b"corev1::Pod\0") .expect("Unreachable: A null byte was specifically inserted")),
        "corev1::PodByName" => Some(::std::ffi::CStr::from_bytes_with_nul(b"corev1::PodByName\0") .expect("Unreachable: A null byte was specifically inserted")),
        "corev1::Selectors" => Some(::std::ffi::CStr::from_bytes_with_nul(b"corev1::Selectors\0") .expect("Unreachable: A null byte was specifically inserted")),
        "corev1::Service" => Some(::std::ffi::CStr::from_bytes_with_nul(b"corev1::Service\0") .expect("Unreachable: A null byte was specifically inserted")),
        "corev1::ServiceByName" => Some(::std::ffi::CStr::from_bytes_with_nul(b"corev1::ServiceByName\0") .expect("Unreachable: A null byte was specifically inserted")),
        "corev1::ServiceMatchesPod" => Some(::std::ffi::CStr::from_bytes_with_nul(b"corev1::ServiceMatchesPod\0") .expect("Unreachable: A null byte was specifically inserted")),
        "ddlog_std::Singleton" => Some(::std::ffi::CStr::from_bytes_with_nul(b"ddlog_std::Singleton\0") .expect("Unreachable: A null byte was specifically inserted")),
        "networkingv1::Ingress" => Some(::std::ffi::CStr::from_bytes_with_nul(b"networkingv1::Ingress\0") .expect("Unreachable: A null byte was specifically inserted")),
        "networkingv1::IngressByName" => Some(::std::ffi::CStr::from_bytes_with_nul(b"networkingv1::IngressByName\0") .expect("Unreachable: A null byte was specifically inserted")),
        "networkingv1::IngressToService" => Some(::std::ffi::CStr::from_bytes_with_nul(b"networkingv1::IngressToService\0") .expect("Unreachable: A null byte was specifically inserted")),
       _  => None
   }
}
pub fn orig_rel_name2name(rname: &str) -> ::std::option::Option<&'static str> {
   match rname {
        "IngressController" => ::core::option::Option::Some("IngressController"),
        "IsPublic" => ::core::option::Option::Some("IsPublic"),
        "NodesInUse" => ::core::option::Option::Some("NodesInUse"),
        "appsv1::ReplicaSet" => ::core::option::Option::Some("appsv1::ReplicaSet"),
        "appsv1::ReplicaSetByName" => ::core::option::Option::Some("appsv1::ReplicaSetByName"),
        "appsv1::ReplicaSetMatchesPod" => ::core::option::Option::Some("appsv1::ReplicaSetMatchesPod"),
        "corev1::MatchesPod" => ::core::option::Option::Some("corev1::MatchesPod"),
        "corev1::Pod" => ::core::option::Option::Some("corev1::Pod"),
        "corev1::PodByName" => ::core::option::Option::Some("corev1::PodByName"),
        "corev1::Selectors" => ::core::option::Option::Some("corev1::Selectors"),
        "corev1::Service" => ::core::option::Option::Some("corev1::Service"),
        "corev1::ServiceByName" => ::core::option::Option::Some("corev1::ServiceByName"),
        "corev1::ServiceMatchesPod" => ::core::option::Option::Some("corev1::ServiceMatchesPod"),
        "ddlog_std::Singleton" => ::core::option::Option::Some("ddlog_std::Singleton"),
        "networkingv1::Ingress" => ::core::option::Option::Some("networkingv1::Ingress"),
        "networkingv1::IngressByName" => ::core::option::Option::Some("networkingv1::IngressByName"),
        "networkingv1::IngressToService" => ::core::option::Option::Some("networkingv1::IngressToService"),
       _  => None
   }
}
/// A map of `RelId`s to their name as an `&'static str`
pub static RELIDMAP: ::once_cell::sync::Lazy<::fnv::FnvHashMap<Relations, &'static str>> =
    ::once_cell::sync::Lazy::new(|| {
        let mut map = ::fnv::FnvHashMap::with_capacity_and_hasher(17, ::fnv::FnvBuildHasher::default());
        map.insert(Relations::IngressController, "IngressController");
        map.insert(Relations::IsPublic, "IsPublic");
        map.insert(Relations::NodesInUse, "NodesInUse");
        map.insert(Relations::appsv1_ReplicaSet, "appsv1::ReplicaSet");
        map.insert(Relations::appsv1_ReplicaSetByName, "appsv1::ReplicaSetByName");
        map.insert(Relations::appsv1_ReplicaSetMatchesPod, "appsv1::ReplicaSetMatchesPod");
        map.insert(Relations::corev1_MatchesPod, "corev1::MatchesPod");
        map.insert(Relations::corev1_Pod, "corev1::Pod");
        map.insert(Relations::corev1_PodByName, "corev1::PodByName");
        map.insert(Relations::corev1_Selectors, "corev1::Selectors");
        map.insert(Relations::corev1_Service, "corev1::Service");
        map.insert(Relations::corev1_ServiceByName, "corev1::ServiceByName");
        map.insert(Relations::corev1_ServiceMatchesPod, "corev1::ServiceMatchesPod");
        map.insert(Relations::ddlog_std_Singleton, "ddlog_std::Singleton");
        map.insert(Relations::networkingv1_Ingress, "networkingv1::Ingress");
        map.insert(Relations::networkingv1_IngressByName, "networkingv1::IngressByName");
        map.insert(Relations::networkingv1_IngressToService, "networkingv1::IngressToService");
        map
    });
/// A map of `RelId`s to their name as an `&'static CStr`
#[cfg(feature = "c_api")]
pub static RELIDMAPC: ::once_cell::sync::Lazy<::fnv::FnvHashMap<program::RelId, &'static ::std::ffi::CStr>> =
    ::once_cell::sync::Lazy::new(|| {
        let mut map = ::fnv::FnvHashMap::with_capacity_and_hasher(17, ::fnv::FnvBuildHasher::default());
        map.insert(0, ::std::ffi::CStr::from_bytes_with_nul(b"IngressController\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(1, ::std::ffi::CStr::from_bytes_with_nul(b"IsPublic\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(2, ::std::ffi::CStr::from_bytes_with_nul(b"NodesInUse\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(3, ::std::ffi::CStr::from_bytes_with_nul(b"appsv1::ReplicaSet\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(4, ::std::ffi::CStr::from_bytes_with_nul(b"appsv1::ReplicaSetByName\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(5, ::std::ffi::CStr::from_bytes_with_nul(b"appsv1::ReplicaSetMatchesPod\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(6, ::std::ffi::CStr::from_bytes_with_nul(b"corev1::MatchesPod\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(7, ::std::ffi::CStr::from_bytes_with_nul(b"corev1::Pod\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(8, ::std::ffi::CStr::from_bytes_with_nul(b"corev1::PodByName\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(9, ::std::ffi::CStr::from_bytes_with_nul(b"corev1::Selectors\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(10, ::std::ffi::CStr::from_bytes_with_nul(b"corev1::Service\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(11, ::std::ffi::CStr::from_bytes_with_nul(b"corev1::ServiceByName\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(12, ::std::ffi::CStr::from_bytes_with_nul(b"corev1::ServiceMatchesPod\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(13, ::std::ffi::CStr::from_bytes_with_nul(b"ddlog_std::Singleton\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(14, ::std::ffi::CStr::from_bytes_with_nul(b"networkingv1::Ingress\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(15, ::std::ffi::CStr::from_bytes_with_nul(b"networkingv1::IngressByName\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(16, ::std::ffi::CStr::from_bytes_with_nul(b"networkingv1::IngressToService\0").expect("Unreachable: A null byte was specifically inserted"));
        map
    });
/// A map of input `Relations`s to their name as an `&'static str`
pub static INPUT_RELIDMAP: ::once_cell::sync::Lazy<::fnv::FnvHashMap<Relations, &'static str>> =
    ::once_cell::sync::Lazy::new(|| {
        let mut map = ::fnv::FnvHashMap::with_capacity_and_hasher(6, ::fnv::FnvBuildHasher::default());
        map.insert(Relations::IngressController, "IngressController");
        map.insert(Relations::appsv1_ReplicaSet, "appsv1::ReplicaSet");
        map.insert(Relations::corev1_Pod, "corev1::Pod");
        map.insert(Relations::corev1_Selectors, "corev1::Selectors");
        map.insert(Relations::corev1_Service, "corev1::Service");
        map.insert(Relations::networkingv1_Ingress, "networkingv1::Ingress");
        map
    });
/// A map of output `Relations`s to their name as an `&'static str`
pub static OUTPUT_RELIDMAP: ::once_cell::sync::Lazy<::fnv::FnvHashMap<Relations, &'static str>> =
    ::once_cell::sync::Lazy::new(|| {
        let mut map = ::fnv::FnvHashMap::with_capacity_and_hasher(6, ::fnv::FnvBuildHasher::default());
        map.insert(Relations::IsPublic, "IsPublic");
        map.insert(Relations::NodesInUse, "NodesInUse");
        map.insert(Relations::appsv1_ReplicaSetMatchesPod, "appsv1::ReplicaSetMatchesPod");
        map.insert(Relations::corev1_MatchesPod, "corev1::MatchesPod");
        map.insert(Relations::corev1_ServiceMatchesPod, "corev1::ServiceMatchesPod");
        map.insert(Relations::networkingv1_IngressToService, "networkingv1::IngressToService");
        map
    });
impl TryFrom<&str> for Indexes {
    type Error = ();
    fn try_from(iname: &str) -> ::std::result::Result<Self, ()> {
         match iname {
        "corev1::MatchesPod" => Ok(Indexes::corev1_MatchesPod),
        "corev1::MatchesPodAll" => Ok(Indexes::corev1_MatchesPodAll),
             _  => Err(())
         }
    }
}
impl TryFrom<program::IdxId> for Indexes {
    type Error = ();
    fn try_from(iid: program::IdxId) -> ::core::result::Result<Self, ()> {
         match iid {
        0 => Ok(Indexes::corev1_MatchesPod),
        1 => Ok(Indexes::corev1_MatchesPodAll),
             _  => Err(())
         }
    }
}
pub fn indexid2name(iid: program::IdxId) -> ::std::option::Option<&'static str> {
   match iid {
        0 => ::core::option::Option::Some("corev1::MatchesPod"),
        1 => ::core::option::Option::Some("corev1::MatchesPodAll"),
       _  => None
   }
}
#[cfg(feature = "c_api")]
pub fn indexid2cname(iid: program::IdxId) -> ::std::option::Option<&'static ::std::ffi::CStr> {
    IDXIDMAPC.get(&iid).copied()
}
/// A map of `Indexes` to their name as an `&'static str`
pub static IDXIDMAP: ::once_cell::sync::Lazy<::fnv::FnvHashMap<Indexes, &'static str>> =
    ::once_cell::sync::Lazy::new(|| {
        let mut map = ::fnv::FnvHashMap::with_capacity_and_hasher(2, ::fnv::FnvBuildHasher::default());
        map.insert(Indexes::corev1_MatchesPod, "corev1::MatchesPod");
        map.insert(Indexes::corev1_MatchesPodAll, "corev1::MatchesPodAll");
        map
    });
/// A map of `IdxId`s to their name as an `&'static CStr`
#[cfg(feature = "c_api")]
pub static IDXIDMAPC: ::once_cell::sync::Lazy<::fnv::FnvHashMap<program::IdxId, &'static ::std::ffi::CStr>> =
    ::once_cell::sync::Lazy::new(|| {
        let mut map = ::fnv::FnvHashMap::with_capacity_and_hasher(2, ::fnv::FnvBuildHasher::default());
        map.insert(0, ::std::ffi::CStr::from_bytes_with_nul(b"corev1::MatchesPod\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(1, ::std::ffi::CStr::from_bytes_with_nul(b"corev1::MatchesPodAll\0").expect("Unreachable: A null byte was specifically inserted"));
        map
    });
pub fn relval_from_record(relation: Relations, record: &::differential_datalog::record::Record) -> ::std::result::Result<::differential_datalog::ddval::DDValue, ::std::string::String> {
    match relation {
        Relations::IngressController => {
            Ok(<types::IngressController as ::differential_datalog::record::FromRecord>::from_record(record)?.into_ddvalue())
        },
        Relations::IsPublic => {
            Ok(<types::IsPublic as ::differential_datalog::record::FromRecord>::from_record(record)?.into_ddvalue())
        },
        Relations::NodesInUse => {
            Ok(<types::NodesInUse as ::differential_datalog::record::FromRecord>::from_record(record)?.into_ddvalue())
        },
        Relations::appsv1_ReplicaSet => {
            Ok(<ddlog_std::Ref<types__appsv1::ReplicaSet> as ::differential_datalog::record::FromRecord>::from_record(record)?.into_ddvalue())
        },
        Relations::appsv1_ReplicaSetByName => {
            Ok(<types__appsv1::ReplicaSetByName as ::differential_datalog::record::FromRecord>::from_record(record)?.into_ddvalue())
        },
        Relations::appsv1_ReplicaSetMatchesPod => {
            Ok(<types__appsv1::ReplicaSetMatchesPod as ::differential_datalog::record::FromRecord>::from_record(record)?.into_ddvalue())
        },
        Relations::corev1_MatchesPod => {
            Ok(<types__corev1::MatchesPod as ::differential_datalog::record::FromRecord>::from_record(record)?.into_ddvalue())
        },
        Relations::corev1_Pod => {
            Ok(<ddlog_std::Ref<types__corev1::Pod> as ::differential_datalog::record::FromRecord>::from_record(record)?.into_ddvalue())
        },
        Relations::corev1_PodByName => {
            Ok(<types__corev1::PodByName as ::differential_datalog::record::FromRecord>::from_record(record)?.into_ddvalue())
        },
        Relations::corev1_Selectors => {
            Ok(<types__corev1::Selectors as ::differential_datalog::record::FromRecord>::from_record(record)?.into_ddvalue())
        },
        Relations::corev1_Service => {
            Ok(<ddlog_std::Ref<types__corev1::Service> as ::differential_datalog::record::FromRecord>::from_record(record)?.into_ddvalue())
        },
        Relations::corev1_ServiceByName => {
            Ok(<types__corev1::ServiceByName as ::differential_datalog::record::FromRecord>::from_record(record)?.into_ddvalue())
        },
        Relations::corev1_ServiceMatchesPod => {
            Ok(<types__corev1::ServiceMatchesPod as ::differential_datalog::record::FromRecord>::from_record(record)?.into_ddvalue())
        },
        Relations::ddlog_std_Singleton => {
            Ok(<ddlog_std::Singleton as ::differential_datalog::record::FromRecord>::from_record(record)?.into_ddvalue())
        },
        Relations::networkingv1_Ingress => {
            Ok(<ddlog_std::Ref<types__networkingv1::Ingress> as ::differential_datalog::record::FromRecord>::from_record(record)?.into_ddvalue())
        },
        Relations::networkingv1_IngressByName => {
            Ok(<types__networkingv1::IngressByName as ::differential_datalog::record::FromRecord>::from_record(record)?.into_ddvalue())
        },
        Relations::networkingv1_IngressToService => {
            Ok(<types__networkingv1::IngressToService as ::differential_datalog::record::FromRecord>::from_record(record)?.into_ddvalue())
        }
    }
}
pub fn relkey_from_record(relation: Relations, record: &::differential_datalog::record::Record) -> ::std::result::Result<::differential_datalog::ddval::DDValue, ::std::string::String> {
    match relation {
        Relations::appsv1_ReplicaSet => {
            Ok(<ddlog_std::tuple2<String, String> as ::differential_datalog::record::FromRecord>::from_record(record)?.into_ddvalue())
        },
        Relations::corev1_Pod => {
            Ok(<ddlog_std::tuple2<String, String> as ::differential_datalog::record::FromRecord>::from_record(record)?.into_ddvalue())
        },
        Relations::corev1_Selectors => {
            Ok(<types__corev1::Selectors as ::differential_datalog::record::FromRecord>::from_record(record)?.into_ddvalue())
        },
        Relations::corev1_Service => {
            Ok(<ddlog_std::tuple2<String, String> as ::differential_datalog::record::FromRecord>::from_record(record)?.into_ddvalue())
        },
        Relations::networkingv1_Ingress => {
            Ok(<ddlog_std::tuple2<String, String> as ::differential_datalog::record::FromRecord>::from_record(record)?.into_ddvalue())
        }
        _ => Err(format!("relation {:?} does not have a primary key", relation)),
    }
}
pub fn idxkey_from_record(idx: Indexes, record: &::differential_datalog::record::Record) -> ::std::result::Result<::differential_datalog::ddval::DDValue, ::std::string::String> {
    match idx {
        Indexes::corev1_MatchesPod => {
            Ok(<ddlog_std::tuple2<types__selectors::LabelSelector, String> as ::differential_datalog::record::FromRecord>::from_record(record)?.into_ddvalue())
        },
        Indexes::corev1_MatchesPodAll => {
            Ok(<types__selectors::LabelSelector as ::differential_datalog::record::FromRecord>::from_record(record)?.into_ddvalue())
        }
    }
}
pub fn indexes2arrid(idx: Indexes) -> program::ArrId {
    match idx {
        Indexes::corev1_MatchesPod => ( 6, 0),
        Indexes::corev1_MatchesPodAll => ( 6, 1),
    }
}
#[derive(Copy,Clone,Debug,PartialEq,Eq,Hash)]
pub enum Relations {
    IngressController = 0,
    IsPublic = 1,
    NodesInUse = 2,
    appsv1_ReplicaSet = 3,
    appsv1_ReplicaSetByName = 4,
    appsv1_ReplicaSetMatchesPod = 5,
    corev1_MatchesPod = 6,
    corev1_Pod = 7,
    corev1_PodByName = 8,
    corev1_Selectors = 9,
    corev1_Service = 10,
    corev1_ServiceByName = 11,
    corev1_ServiceMatchesPod = 12,
    ddlog_std_Singleton = 13,
    networkingv1_Ingress = 14,
    networkingv1_IngressByName = 15,
    networkingv1_IngressToService = 16
}
#[derive(Copy,Clone,Debug,PartialEq,Eq,Hash)]
pub enum Indexes {
    corev1_MatchesPod = 0,
    corev1_MatchesPodAll = 1
}
impl_trait_d3log!();
pub fn prog(__update_cb: std::sync::Arc<dyn program::RelationCallback>) -> program::Program {
    let IngressController = ::differential_datalog::program::Relation {
        name: ::std::borrow::Cow::Borrowed("IngressController"),
        source_pos: ::ddlog_profiler::SourcePosition::new_range("pallograph.dl", 7, 1, 9, 1),
        input: true,
        distinct: false,
        caching_mode: ::differential_datalog::program::CachingMode::Set,
        key_func: ::core::option::Option::None,
        id: 0,
        rules: vec![
        ],
        arrangements: vec![
            types::__Arng_IngressController_0.clone().set_debug_info(::ddlog_profiler::ArrangementDebugInfo::new(::std::borrow::Cow::Borrowed("(IngressController{.ns=_0, .name=_1, .className=(_: string)}: IngressController)"), &[::ddlog_profiler::SourcePosition::new_range("pallograph.dl", 21, 3, 21, 72)], &[])),
        ],
        change_cb: ::core::option::Option::None,
    };
    let appsv1_ReplicaSet = ::differential_datalog::program::Relation {
        name: ::std::borrow::Cow::Borrowed("appsv1::ReplicaSet"),
        source_pos: ::ddlog_profiler::SourcePosition::new_range("appsv1.dl", 11, 1, 14, 1),
        input: true,
        distinct: false,
        caching_mode: ::differential_datalog::program::CachingMode::Set,
        key_func: ::core::option::Option::Some(types__appsv1::__Key_appsv1_ReplicaSet),
        id: 3,
        rules: vec![
        ],
        arrangements: vec![
        ],
        change_cb: ::core::option::Option::None,
    };
    let appsv1_ReplicaSetByName = ::differential_datalog::program::Relation {
        name: ::std::borrow::Cow::Borrowed("appsv1::ReplicaSetByName"),
        source_pos: ::ddlog_profiler::SourcePosition::new_range("appsv1.dl", 14, 1, 15, 1),
        input: false,
        distinct: false,
        caching_mode: ::differential_datalog::program::CachingMode::Set,
        key_func: ::core::option::Option::None,
        id: 4,
        rules: vec![
            types__appsv1::__Rule_appsv1_ReplicaSetByName_0.clone(),
        ],
        arrangements: vec![
            types__appsv1::__Arng_appsv1_ReplicaSetByName_0.clone().set_debug_info(::ddlog_profiler::ArrangementDebugInfo::new(::std::borrow::Cow::Borrowed("(appsv1::ReplicaSetByName{.rs=(_: ddlog_std::Ref<appsv1::ReplicaSet>), .ns=(_0: string), .name=(_: string)}: appsv1::ReplicaSetByName)"), &[::ddlog_profiler::SourcePosition::new_range("appsv1.dl", 22, 3, 22, 30)], &[])),
        ],
        change_cb: ::core::option::Option::None,
    };
    let corev1_Pod = ::differential_datalog::program::Relation {
        name: ::std::borrow::Cow::Borrowed("corev1::Pod"),
        source_pos: ::ddlog_profiler::SourcePosition::new_range("corev1.dl", 18, 1, 21, 1),
        input: true,
        distinct: false,
        caching_mode: ::differential_datalog::program::CachingMode::Set,
        key_func: ::core::option::Option::Some(types__corev1::__Key_corev1_Pod),
        id: 7,
        rules: vec![
        ],
        arrangements: vec![
        ],
        change_cb: ::core::option::Option::None,
    };
    let NodesInUse = ::differential_datalog::program::Relation {
        name: ::std::borrow::Cow::Borrowed("NodesInUse"),
        source_pos: ::ddlog_profiler::SourcePosition::new_range("pallograph.dl", 9, 1, 10, 1),
        input: false,
        distinct: true,
        caching_mode: ::differential_datalog::program::CachingMode::Set,
        key_func: ::core::option::Option::None,
        id: 2,
        rules: vec![
            types::__Rule_NodesInUse_0.clone(),
        ],
        arrangements: vec![
        ],
        change_cb: ::core::option::Option::Some(::std::sync::Arc::clone(&__update_cb)),
    };
    let corev1_PodByName = ::differential_datalog::program::Relation {
        name: ::std::borrow::Cow::Borrowed("corev1::PodByName"),
        source_pos: ::ddlog_profiler::SourcePosition::new_range("corev1.dl", 21, 1, 22, 1),
        input: false,
        distinct: false,
        caching_mode: ::differential_datalog::program::CachingMode::Set,
        key_func: ::core::option::Option::None,
        id: 8,
        rules: vec![
            types__corev1::__Rule_corev1_PodByName_0.clone(),
        ],
        arrangements: vec![
            types__corev1::__Arng_corev1_PodByName_0.clone().set_debug_info(::ddlog_profiler::ArrangementDebugInfo::new(::std::borrow::Cow::Borrowed("(corev1::PodByName{.pod=(_: ddlog_std::Ref<corev1::Pod>), .ns=(_0: string), .name=(_: string)}: corev1::PodByName)"), &[::ddlog_profiler::SourcePosition::new_range("corev1.dl", 69, 3, 69, 24), ::ddlog_profiler::SourcePosition::new_range("appsv1.dl", 23, 3, 23, 24)], &[])),
            types__corev1::__Arng_corev1_PodByName_1.clone().set_debug_info(::ddlog_profiler::ArrangementDebugInfo::new(::std::borrow::Cow::Borrowed("(corev1::PodByName{.pod=(_: ddlog_std::Ref<corev1::Pod>), .ns=(_: string), .name=(_: string)}: corev1::PodByName)"), &[::ddlog_profiler::SourcePosition::new_range("corev1.dl", 38, 3, 38, 24)], &[])),
        ],
        change_cb: ::core::option::Option::None,
    };
    let appsv1_ReplicaSetMatchesPod = ::differential_datalog::program::Relation {
        name: ::std::borrow::Cow::Borrowed("appsv1::ReplicaSetMatchesPod"),
        source_pos: ::ddlog_profiler::SourcePosition::new_range("appsv1.dl", 20, 1, 21, 1),
        input: false,
        distinct: true,
        caching_mode: ::differential_datalog::program::CachingMode::Set,
        key_func: ::core::option::Option::None,
        id: 5,
        rules: vec![
            types__appsv1::__Rule_appsv1_ReplicaSetMatchesPod_0.clone(),
        ],
        arrangements: vec![
        ],
        change_cb: ::core::option::Option::Some(::std::sync::Arc::clone(&__update_cb)),
    };
    let corev1_Selectors = ::differential_datalog::program::Relation {
        name: ::std::borrow::Cow::Borrowed("corev1::Selectors"),
        source_pos: ::ddlog_profiler::SourcePosition::new_range("corev1.dl", 28, 1, 31, 1),
        input: true,
        distinct: false,
        caching_mode: ::differential_datalog::program::CachingMode::Set,
        key_func: ::core::option::Option::Some(types__corev1::__Key_corev1_Selectors),
        id: 9,
        rules: vec![
        ],
        arrangements: vec![
            types__corev1::__Arng_corev1_Selectors_0.clone().set_debug_info(::ddlog_profiler::ArrangementDebugInfo::new(::std::borrow::Cow::Borrowed("(corev1::Selectors{.s=(_: selectors::LabelSelector)}: corev1::Selectors)"), &[::ddlog_profiler::SourcePosition::new_range("corev1.dl", 37, 3, 37, 22)], &[])),
        ],
        change_cb: ::core::option::Option::None,
    };
    let corev1_MatchesPod = ::differential_datalog::program::Relation {
        name: ::std::borrow::Cow::Borrowed("corev1::MatchesPod"),
        source_pos: ::ddlog_profiler::SourcePosition::new_range("corev1.dl", 33, 1, 34, 1),
        input: false,
        distinct: true,
        caching_mode: ::differential_datalog::program::CachingMode::Set,
        key_func: ::core::option::Option::None,
        id: 6,
        rules: vec![
            types__corev1::__Rule_corev1_MatchesPod_0.clone(),
        ],
        arrangements: vec![
            types__corev1::__Arng_corev1_MatchesPod_0.clone().set_debug_info(::ddlog_profiler::ArrangementDebugInfo::new(::std::borrow::Cow::Borrowed("(corev1::MatchesPod{.selector=_0, .namespace=_1, .pod=(_: ddlog_std::Ref<corev1::Pod>)}: corev1::MatchesPod)"), &[::ddlog_profiler::SourcePosition::new_range("corev1.dl", 34, 1, 35, 1)], &[::std::borrow::Cow::Borrowed("corev1::MatchesPod")])),
            types__corev1::__Arng_corev1_MatchesPod_1.clone().set_debug_info(::ddlog_profiler::ArrangementDebugInfo::new(::std::borrow::Cow::Borrowed("(corev1::MatchesPod{.selector=_0, .namespace=(_: string), .pod=(_: ddlog_std::Ref<corev1::Pod>)}: corev1::MatchesPod)"), &[::ddlog_profiler::SourcePosition::new_range("corev1.dl", 35, 1, 36, 1)], &[::std::borrow::Cow::Borrowed("corev1::MatchesPodAll")])),
        ],
        change_cb: ::core::option::Option::Some(::std::sync::Arc::clone(&__update_cb)),
    };
    let corev1_Service = ::differential_datalog::program::Relation {
        name: ::std::borrow::Cow::Borrowed("corev1::Service"),
        source_pos: ::ddlog_profiler::SourcePosition::new_range("corev1.dl", 57, 1, 60, 1),
        input: true,
        distinct: false,
        caching_mode: ::differential_datalog::program::CachingMode::Set,
        key_func: ::core::option::Option::Some(types__corev1::__Key_corev1_Service),
        id: 10,
        rules: vec![
        ],
        arrangements: vec![
        ],
        change_cb: ::core::option::Option::None,
    };
    let corev1_ServiceByName = ::differential_datalog::program::Relation {
        name: ::std::borrow::Cow::Borrowed("corev1::ServiceByName"),
        source_pos: ::ddlog_profiler::SourcePosition::new_range("corev1.dl", 60, 1, 61, 1),
        input: false,
        distinct: false,
        caching_mode: ::differential_datalog::program::CachingMode::Set,
        key_func: ::core::option::Option::None,
        id: 11,
        rules: vec![
            types__corev1::__Rule_corev1_ServiceByName_0.clone(),
        ],
        arrangements: vec![
            types__corev1::__Arng_corev1_ServiceByName_0.clone().set_debug_info(::ddlog_profiler::ArrangementDebugInfo::new(::std::borrow::Cow::Borrowed("(corev1::ServiceByName{.svc=(_: ddlog_std::Ref<corev1::Service>), .ns=(_0: string), .name=(_: string)}: corev1::ServiceByName)"), &[::ddlog_profiler::SourcePosition::new_range("corev1.dl", 68, 3, 68, 28)], &[])),
            types__corev1::__Arng_corev1_ServiceByName_1.clone().set_debug_info(::ddlog_profiler::ArrangementDebugInfo::new(::std::borrow::Cow::Borrowed("(corev1::ServiceByName{.svc=(_: ddlog_std::Ref<corev1::Service>), .ns=_0, .name=(_1: string)}: corev1::ServiceByName)"), &[::ddlog_profiler::SourcePosition::new_range("networkingv1.dl", 33, 3, 33, 50)], &[])),
        ],
        change_cb: ::core::option::Option::None,
    };
    let corev1_ServiceMatchesPod = ::differential_datalog::program::Relation {
        name: ::std::borrow::Cow::Borrowed("corev1::ServiceMatchesPod"),
        source_pos: ::ddlog_profiler::SourcePosition::new_range("corev1.dl", 66, 1, 67, 1),
        input: false,
        distinct: true,
        caching_mode: ::differential_datalog::program::CachingMode::Set,
        key_func: ::core::option::Option::None,
        id: 12,
        rules: vec![
            types__corev1::__Rule_corev1_ServiceMatchesPod_0.clone(),
        ],
        arrangements: vec![
        ],
        change_cb: ::core::option::Option::Some(::std::sync::Arc::clone(&__update_cb)),
    };
    let ddlog_std_Singleton = ::differential_datalog::program::Relation {
        name: ::std::borrow::Cow::Borrowed("ddlog_std::Singleton"),
        source_pos: ::ddlog_profiler::SourcePosition::new_range("ddlog_std.dl", 939, 1, 940, 1),
        input: false,
        distinct: false,
        caching_mode: ::differential_datalog::program::CachingMode::Set,
        key_func: ::core::option::Option::None,
        id: 13,
        rules: vec![
        ],
        arrangements: vec![
        ],
        change_cb: ::core::option::Option::None,
    };
    let networkingv1_Ingress = ::differential_datalog::program::Relation {
        name: ::std::borrow::Cow::Borrowed("networkingv1::Ingress"),
        source_pos: ::ddlog_profiler::SourcePosition::new_range("networkingv1.dl", 19, 1, 22, 1),
        input: true,
        distinct: false,
        caching_mode: ::differential_datalog::program::CachingMode::Set,
        key_func: ::core::option::Option::Some(types__networkingv1::__Key_networkingv1_Ingress),
        id: 14,
        rules: vec![
        ],
        arrangements: vec![
        ],
        change_cb: ::core::option::Option::None,
    };
    let networkingv1_IngressToService = ::differential_datalog::program::Relation {
        name: ::std::borrow::Cow::Borrowed("networkingv1::IngressToService"),
        source_pos: ::ddlog_profiler::SourcePosition::new_range("networkingv1.dl", 28, 1, 29, 1),
        input: false,
        distinct: true,
        caching_mode: ::differential_datalog::program::CachingMode::Set,
        key_func: ::core::option::Option::None,
        id: 16,
        rules: vec![
            types__networkingv1::__Rule_networkingv1_IngressToService_0.clone(),
        ],
        arrangements: vec![
            types__networkingv1::__Arng_networkingv1_IngressToService_0.clone().set_debug_info(::ddlog_profiler::ArrangementDebugInfo::new(::std::borrow::Cow::Borrowed("(networkingv1::IngressToService{.ing=(_0: ddlog_std::Ref<networkingv1::Ingress>), .svc=(_: ddlog_std::Ref<corev1::Service>)}: networkingv1::IngressToService)"), &[::ddlog_profiler::SourcePosition::new_range("pallograph.dl", 23, 3, 23, 43)], &[])),
        ],
        change_cb: ::core::option::Option::Some(::std::sync::Arc::clone(&__update_cb)),
    };
    let networkingv1_IngressByName = ::differential_datalog::program::Relation {
        name: ::std::borrow::Cow::Borrowed("networkingv1::IngressByName"),
        source_pos: ::ddlog_profiler::SourcePosition::new_range("networkingv1.dl", 22, 1, 23, 1),
        input: false,
        distinct: false,
        caching_mode: ::differential_datalog::program::CachingMode::Set,
        key_func: ::core::option::Option::None,
        id: 15,
        rules: vec![
            types__networkingv1::__Rule_networkingv1_IngressByName_0.clone(),
        ],
        arrangements: vec![
            types__networkingv1::__Arng_networkingv1_IngressByName_0.clone().set_debug_info(::ddlog_profiler::ArrangementDebugInfo::new(::std::borrow::Cow::Borrowed("(networkingv1::IngressByName{.ing=(_: ddlog_std::Ref<networkingv1::Ingress>), .ns=_0, .name=_1}: networkingv1::IngressByName)"), &[::ddlog_profiler::SourcePosition::new_range("pallograph.dl", 22, 3, 22, 76)], &[])),
        ],
        change_cb: ::core::option::Option::None,
    };
    let IsPublic = ::differential_datalog::program::Relation {
        name: ::std::borrow::Cow::Borrowed("IsPublic"),
        source_pos: ::ddlog_profiler::SourcePosition::new_range("pallograph.dl", 14, 1, 15, 1),
        input: false,
        distinct: false,
        caching_mode: ::differential_datalog::program::CachingMode::Set,
        key_func: ::core::option::Option::None,
        id: 1,
        rules: vec![
            types::__Rule_IsPublic_0.clone(),
            types::__Rule_IsPublic_1.clone(),
        ],
        arrangements: vec![
        ],
        change_cb: ::core::option::Option::Some(::std::sync::Arc::clone(&__update_cb)),
    };
    let nodes: std::vec::Vec<program::ProgNode> = vec![
            program::ProgNode::Rel{rel: IngressController},
            program::ProgNode::Rel{rel: appsv1_ReplicaSet},
            program::ProgNode::Rel{rel: appsv1_ReplicaSetByName},
            program::ProgNode::Rel{rel: corev1_Pod},
            program::ProgNode::Rel{rel: NodesInUse},
            program::ProgNode::Rel{rel: corev1_PodByName},
            program::ProgNode::Rel{rel: appsv1_ReplicaSetMatchesPod},
            program::ProgNode::Rel{rel: corev1_Selectors},
            program::ProgNode::Rel{rel: corev1_MatchesPod},
            program::ProgNode::Rel{rel: corev1_Service},
            program::ProgNode::Rel{rel: corev1_ServiceByName},
            program::ProgNode::Rel{rel: corev1_ServiceMatchesPod},
            program::ProgNode::Rel{rel: ddlog_std_Singleton},
            program::ProgNode::Rel{rel: networkingv1_Ingress},
            program::ProgNode::Rel{rel: networkingv1_IngressToService},
            program::ProgNode::Rel{rel: networkingv1_IngressByName},
            program::ProgNode::Scc{rels: vec![program::RecursiveRelation{rel: IsPublic, distinct: true}]}
    ];
    let delayed_rels = vec![];
    let init_data: std::vec::Vec<(program::RelId, ::differential_datalog::ddval::DDValue)> = vec![types__corev1::__Fact_corev1_Selectors_0.clone(),
                                                                                                  ddlog_std::__Fact_ddlog_std_Singleton_0.clone()];
    program::Program {
        nodes,
        delayed_rels,
        init_data,
    }
}
static SOURCES: &'static [ddlog_profiler::SourceFile] = &[
    ddlog_profiler::SourceFile{filename: "pallograph.dl", contents: std::include_str!("/home/andrew/src/github.com/williamsandrew/pallograph/pallograph.dl")},
    ddlog_profiler::SourceFile{filename: "appsv1.dl", contents: std::include_str!("/home/andrew/src/github.com/williamsandrew/pallograph/appsv1.dl")},
    ddlog_profiler::SourceFile{filename: "corev1.dl", contents: std::include_str!("/home/andrew/src/github.com/williamsandrew/pallograph/corev1.dl")},
    ddlog_profiler::SourceFile{filename: "ddlog_bigint.dl", contents: std::include_str!("/opt/ddlog/ddlog-1.2.3/lib/ddlog_bigint.dl")},
    ddlog_profiler::SourceFile{filename: "ddlog_log.dl", contents: std::include_str!("/opt/ddlog/ddlog-1.2.3/lib/ddlog_log.dl")},
    ddlog_profiler::SourceFile{filename: "ddlog_rt.dl", contents: std::include_str!("/opt/ddlog/ddlog-1.2.3/lib/ddlog_rt.dl")},
    ddlog_profiler::SourceFile{filename: "ddlog_std.dl", contents: std::include_str!("/opt/ddlog/ddlog-1.2.3/lib/ddlog_std.dl")},
    ddlog_profiler::SourceFile{filename: "debug.dl", contents: std::include_str!("/opt/ddlog/ddlog-1.2.3/lib/debug.dl")},
    ddlog_profiler::SourceFile{filename: "internment.dl", contents: std::include_str!("/opt/ddlog/ddlog-1.2.3/lib/internment.dl")},
    ddlog_profiler::SourceFile{filename: "metav1.dl", contents: std::include_str!("/home/andrew/src/github.com/williamsandrew/pallograph/metav1.dl")},
    ddlog_profiler::SourceFile{filename: "networkingv1.dl", contents: std::include_str!("/home/andrew/src/github.com/williamsandrew/pallograph/networkingv1.dl")},
    ddlog_profiler::SourceFile{filename: "selectors.dl", contents: std::include_str!("/home/andrew/src/github.com/williamsandrew/pallograph/selectors.dl")}
];